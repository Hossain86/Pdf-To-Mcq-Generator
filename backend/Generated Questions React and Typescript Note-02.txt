Here are 10 narrative questions based on the provided text, formatted as requested:

1: How does React Router enable navigation in a single-page application (SPA), and can you provide a code example from `App.tsx` that demonstrates this?
✅ Answer: React Router allows users to navigate between different pages in an SPA without refreshing the page. In `App.tsx`, the `<BrowserRouter>` component wraps the entire routing configuration. The `<Routes>` component groups the `<Route>` components, each defining a path and the component to display for that path. For instance, `<Route path="/" element={<LandingPage />} />` specifies that when the user visits the homepage (`/`), the `LandingPage` component should be rendered.

2: Explain the purpose of the `useState` hook in React, using examples from both `App.tsx` and `NavbarPage.tsx` to illustrate how it manages component state.
✅ Answer: The `useState` hook allows functional components to have state variables. In `App.tsx`, `const [selectedCategory, setSelectedCategory] = useState<string>("");` initializes `selectedCategory` as an empty string, used to store the currently selected blog category. `setSelectedCategory` is a function to update this value. Similarly, in `NavbarPage.tsx`, `const [isMenuOpen, setIsMenuOpen] = useState<boolean>(false);` manages the state of whether the menu is open or closed, with `setIsMenuOpen` to toggle the menu state.

3: Describe how the `onClick` event handler in `NavbarPage.tsx` changes the state of `isMenuOpen`, and explain the logic behind toggling the menu's visibility.
✅ Answer: In `NavbarPage.tsx`, the menu icon has an `onClick` event handler: `onClick={() => setIsMenuOpen(!isMenuOpen)}`. When the menu icon is clicked, the `setIsMenuOpen` function is called with the opposite of the current `isMenuOpen` value. If `isMenuOpen` is `false`, it becomes `true`, opening the menu. If it's `true`, it becomes `false`, closing the menu. This toggles the menu's visibility each time the icon is clicked.

4: Explain how data, specifically the `setCategory` function, is passed between `App.tsx` and `NavbarPage.tsx`, and how this mechanism facilitates updating the `selectedCategory` state in `App.tsx` when a user interacts with the navbar.
✅ Answer: In `App.tsx`, `setSelectedCategory` function is passed as a prop named `setCategory` to `NavbarPage` component via `<NavbarPage setCategory={setSelectedCategory} />`. In `NavbarPage.tsx`, this prop is received using the `NavbarPageProps` interface, which defines `setCategory` as a function that takes a string and returns nothing. Within `NavbarPage`, clicking a category link triggers a call to `setCategory`, which updates `selectedCategory` in `App.tsx` thereby filtering the Blog.

5: How does the filtering logic in `App.tsx` use the `selectedCategory` state to display the appropriate blog articles, and what happens when `selectedCategory` is empty?
✅ Answer: The `filteredArticles` variable in `App.tsx` is determined by the conditional statement: `selectedCategory ? blogData.filter((article) => article.category === selectedCategory) : blogData;`. If `selectedCategory` has a value (i.e., a category is selected), the `filter` method is used to create a new array containing only the articles whose `category` matches the `selectedCategory`. If `selectedCategory` is empty, `filteredArticles` is simply assigned the entire `blogData` array, showing all blog articles.

6: Explain the purpose of the `useNavigate` hook in `LandingPage.tsx` and how it is used to programmatically navigate the user to the blogs page when they click the "Get Started" button.
✅ Answer: The `useNavigate` hook from `react-router-dom` is used to navigate programmatically without using a `<Link>` component. In `LandingPage.tsx`, `const navigate = useNavigate();` initializes the `navigate` function. When the "Get Started" button is clicked, the `onClick` event handler calls `navigate("/blogs")`, which redirects the user to the `/blogs` route, displaying the blog list.

7: Describe the structure of the `ArticleData` interface in `Block.tsx` and explain how it is used to define the data structure for each blog article.
✅ Answer: The `ArticleData` interface in `Block.tsx` defines the structure of a blog article object. It specifies the following properties: `id` (number), `heading` (string), `imgsrc` (string), `details` (string), `category` (string), `date_created` (string), and `author` (string). These properties define the data types and names of the fields that each blog article should contain. The `articles` prop in the `Block` component is an array of `ArticleData` objects, represented as `articles: ArticleData[]`.

8: Explain how the `useState` hook is used to manage the "Like" feature in `Block.tsx`, and how the initial state of `likedArticles` is determined, including the use of `localStorage`.
✅ Answer: In `Block.tsx`, the `likedArticles` state is managed using `useState<{ [key: number]: boolean }>(() => { ... });`. This creates a state object where the keys are article IDs and the values are booleans indicating whether the article is liked or not. The initial state is determined by checking `localStorage` for previously liked articles. The arrow function ensures this initialization happens only once when the component loads. For each article, it checks if a corresponding entry exists in `localStorage` (`localStorage.getItem(\`liked-\${article.id}\`) === "true"`). If it does, the `likedArticles` state is initialized with the stored like state.

9: How does the `BlogDetails.tsx` component retrieve the blog ID from the URL using the `useParams` hook, and what happens if a blog with the specified ID is not found?
✅ Answer: The `BlogDetails.tsx` component uses the `useParams` hook to extract the blog ID from the URL: `const { id } = useParams();`. This hook retrieves the `id` parameter from the route defined in `App.tsx` (`/blog/:id`). If a blog with the specified ID is not found (i.e., `blog.find((g) => g.id === Number(id))` returns `undefined`), the component renders a "Blog not found!" message, preventing further rendering of the page.

10: Explain how Bootstrap breakpoints work, and give an example of how they are used to create responsive columns in a grid layout.
✅ Answer: Bootstrap breakpoints are screen size ranges where specific CSS styles apply, allowing for responsive layouts. They use class prefixes like `sm`, `md`, `lg`, `xl`, and `xxl` to target different screen sizes. For example, `<div class="col-sm-12 col-md-6 col-lg-4"></div>` specifies that on small screens (less than 576px), the column takes full width (`col-sm-12`), on medium screens (≥768px) it takes 50% width (`col-md-6`), and on large screens (≥992px) it takes 33% width (`col-lg-4`). This allows content to adapt to different screen sizes for optimal viewing.
